// !!!! WARNING !!!!!
// Please note that I cannot guarantee correctness and safety of the code, as SHA256 is not secure.
// echo jk | sha256sum: 720daff2aefd2b3457cbd597509b0fa399e258444302c2851f8d3cdd8ad781eb
// echo ks | sha256sum: 1aa44e718d5bc9b7ff2003dbbb6f154e16636d5c2128ffce4751af5124b65337
// echo xy | sha256sum: 3b2fc206fd92be3e70843a6d6d466b1f400383418b3c16f2f0af89981f1337f3
// echo za | sha256sum: 28832ea947ea9588ff3acbad546b27fd001a875215beccf0e5e4eee51cc81a2e

#pragma once
#include <VehicleArena/Array/Array.hpp>
#include <VehicleArena/Array/Fixed_Array.hpp>
#include <VehicleArena/Geometry/Primitives/Axis_Aligned_Bounding_Box.hpp>
#include <VehicleArena/Math/Ceil.hpp>
#include <VehicleArena/Math/Floor.hpp>
#include <VehicleArena/Stats/Min_Max.hpp>
#include <functional>
#include <sstream>
#include <stdexcept>
#include <vector>

namespace VA {

static struct Recursive {} recursive_v;
static struct NonRecursive {} non_recursive_v;

template <class TData>
class IntersectionGridPointerEntry {
public:
    explicit IntersectionGridPointerEntry(TData* data)
        : data_{ data }
    {}
    template <class... TVisitors>
    bool visit_data(const auto& aabb, TVisitors... visitors) const {
        return data_->visit_data(aabb, visitors...);
    }
    template <class... TVisitors>
    bool visit(const auto& aabb, TVisitors... visitors) const {
        return data_->visit(aabb, visitors...);
    }
private:
    TData* data_;
};

template <class TNonRecursive, class TRecursive>
class IntersectionGridEntries {
public:
    template <class... TVisitors>
    bool visit(const auto& aabb, TVisitors... visitors) const {
        for (const auto& child : non_recursive_) {
            if (!child.visit_data(aabb, visitors...)) {
                return false;
            }
        }
        for (const auto& child : recursive_) {
            if (!child.visit(aabb, visitors...)) {
                return false;
            }
        }
        return true;
    }
    void push_back(TNonRecursive data0, NonRecursive) {
        non_recursive_.emplace_back(std::move(data0));
    }
    void push_back(TRecursive data1, Recursive) {
        recursive_.emplace_back(std::move(data1));
    }
private:
    std::vector<TNonRecursive> non_recursive_;
    std::vector<TRecursive> recursive_;
};

template <class TPosition, size_t tndim, class TData>
class IntersectionGrid {
public:
    using TUnpackedPosition = funpack_t<TPosition>;
    IntersectionGrid(
        const AxisAlignedBoundingBox<TPosition, tndim>& boundary,
        const FixedArray<size_t, tndim>& ncells,
        const FixedArray<TPosition, tndim>& dilation_radius)
        : data_(ncells.to_array_shape())
        , boundary_{ boundary }
        , ncells_{ ncells.template casted<TUnpackedPosition>() }
        , dilation_radius_{ dilation_radius }
    {
        if (any(ncells == (size_t)0)) {
            throw std::runtime_error("Number of intersection grid cells cannot be zero");
        }
    }
    template <class... Args>
    void insert(const auto& aabb, const auto& entry, Args... args) {
        auto c_min = (funpack(aabb.min - boundary_.min - dilation_radius_)) / funpack(boundary_.size());
        auto c_max = (funpack(aabb.max - boundary_.min + dilation_radius_)) / funpack(boundary_.size());
        if (any(c_min < (TUnpackedPosition)0)) {
            throw std::runtime_error("Intersection grid entry out of lower bounds");
        }
        if (any(c_max > (TUnpackedPosition)1)) {
            throw std::runtime_error("Intersection grid entry out of upper bounds");
        }
        auto id_min = floor(c_min * ncells_).template casted<size_t>();
        auto id_max = minimum(
                floor(c_max * ncells_) + (TUnpackedPosition)1.f,
                ncells_ - (TUnpackedPosition)1.f).template casted<size_t>();
        if (any(id_min >= data_.template fixed_shape<tndim>())) {
            verbose_abort("Intersection grid lower index out of bounds");
        }
        if (any(id_max >= data_.template fixed_shape<tndim>())) {
            verbose_abort("Intersection grid upper index out of bounds");
        }
        AxisAlignedBoundingBox<size_t, tndim>::from_min_max(id_min, id_max).for_each_cell(
            [this, &entry, &args...](const FixedArray<size_t, tndim>& id){
                data_(id).push_back(entry, std::forward<Args>(args)...);
                return true;
            });
    }
    template <class... TVisitors>
    bool visit(const auto& aabb, TVisitors... visitors) const {
        if (auto half_width = aabb.size() / 2; any(half_width > dilation_radius_)) {
            std::stringstream sstr;
            sstr <<
                "Intersection grid: Dilation radius too small. Half width: " <<
                half_width << ". Dilation radius: " << dilation_radius_;
            throw std::runtime_error(sstr.str());
        }
        auto center = aabb.center();
        auto c = (funpack(center - boundary_.min)) / funpack(boundary_.size());
        if (any(c < (TUnpackedPosition)0)) {
            return true;
        }
        if (any(c > (TUnpackedPosition)1)) {
            return true;
        }
        auto id = minimum(floor(c * ncells_), ncells_ - (TUnpackedPosition)1.f).template casted<size_t>();
        if (any(id >= data_.template fixed_shape<tndim>())) {
            verbose_abort("Intersection grid rounded index out of bounds");
        }
        return data_(id).visit(aabb, visitors...);
    }
private:
    Array<TData> data_;
    AxisAlignedBoundingBox<TPosition, tndim> boundary_;
    FixedArray<TUnpackedPosition, tndim> ncells_;
    FixedArray<TPosition, tndim> dilation_radius_;
};

}
